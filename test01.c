/* test01.c */

/* Livermore Loops (http://www.netlib.org/benchmark/livermorec). */

#include <stdio.h>
#include <math.h>
#include <assert.h>

/* Serial code is generated by adding a conditional in inner loops.
   It is asserting a test for a global variable (one=1). */

volatile int one;

/* MEMO: The outer-most loop (iteration for benchmark) is dropped. */

/* COMPILE WITH: gcc -std=c99 -Ofast test02.c -lm */

/*
*******************************************************************
*   Kernel 1 -- hydro fragment
*******************************************************************
*       DO 1 L = 1,Loop
*       DO 1 k = 1,n
*  1       X(k)= Q + Y(k)*(R*ZX(k+10) + T*ZX(k+11))
*/

void __attribute__ ((noinline))
kernel1(int n, double q, double r, double t,
	double * restrict x, const double * y, const double * z)
{
    /*#pragma clang loop vectorize(enable) vectorize_width(8)*/
    for (int k = 0; k < n; k++) {
	x[k] = q + y[k]*( r*z[k+10] + t*z[k+11] );
    }
}

/*
*******************************************************************
*   Kernel 2 -- ICCG excerpt (Incomplete Cholesky Conjugate Gradient)
*******************************************************************
*    DO 200  L= 1,Loop
*        II= n
*     IPNTP= 0
*222   IPNT= IPNTP
*     IPNTP= IPNTP+II
*        II= II/2
*         i= IPNTP
CDIR$ IVDEP
*    DO 2 k= IPNT+2,IPNTP,2
*         i= i+1
*  2   X(i)= X(k) - V(k)*X(k-1) - V(k+1)*X(k+1)
*        IF( II.GT.1) GO TO 222
*200 CONTINUE
*/

void __attribute__ ((noinline))
kernel2(int n, double * restrict x, const double * v)
{
    int ii, ipntp;

    ii = n;
    ipntp = 0;
    do {
	int ipnt = ipntp;
	ipntp += ii;
	ii /= 2;
	int i;
	i = ipntp - 1;
	/*#pragma nohazard*/
	for (int k = ipnt + 1; k < ipntp; k = k + 2) {
	    i++;
	    x[i] = x[k] - v[k  ]*x[k-1] - v[k+1]*x[k+1];
	}
    } while (ii > 0);
}

/*
*******************************************************************
*   Kernel 3 -- inner product
*******************************************************************
*    DO 3 L= 1,Loop
*         Q= 0.0
*    DO 3 k= 1,n
*  3      Q= Q + Z(k)*X(k)
*/

double __attribute__ ((noinline))
kernel3(int n, const double * x, const double * z)
{
    double q;
    q = 0.0;
    for (int k = 0; k < n; k++) {
	q += z[k]*x[k];
    }
    return q;
}

/*
*******************************************************************
*   Kernel 4 -- banded linear equations
*******************************************************************
*            m= (1001-7)/2
*    DO 444  L= 1,Loop
*    DO 444  k= 7,1001,m
*           lw= k-6
*         temp= X(k-1)
*  CDIR$ IVDEP
*    DO   4  j= 5,n,5
*       temp  = temp   - XZ(lw)*Y(j)
*  4        lw= lw+1
*       X(k-1)= Y(5)*temp
*444 CONTINUE
*/

/* KERNEL4 in the C version has typo: input array x[] is xz[]. */

void __attribute__ ((noinline))
kernel4(int n, double * restrict x, const double * y, const double * xz)
{
    int m = ( 1001 - 7 )/2;
    for (int k = 6; k < 1001; k = k + m) {
	int lw = k - 6;
	double temp = xz[k-1];
	/*#pragma nohazard*/
	for (int j = 4; j < n; j = j + 5) {
	    temp -= xz[lw]*y[j];
	    lw++;
	}
	x[k-1] = y[4]*temp;
    }
}

/*
*******************************************************************
*   Kernel 5 -- tri-diagonal elimination, below diagonal
*******************************************************************
*    DO 5 L = 1,Loop
*    DO 5 i = 2,n
*  5    X(i)= Z(i)*(Y(i) - X(i-1))
*/

void __attribute__ ((noinline))
kernel5(int n, double * restrict x, const double * y, const double * z)
{
    for (int i = 1; i < n; i++) {
	x[i] = z[i]*( y[i] - x[i-1] );
    }
}

/*
*******************************************************************
*   Kernel 6 -- general linear recurrence equations
*******************************************************************
*    DO  6  L= 1,Loop
*    DO  6  i= 2,n
*    DO  6  k= 1,i-1
*        W(i)= W(i)  + B(i,k) * W(i-k)
*  6 CONTINUE
*/

/* b[64][64] */

void __attribute__ ((noinline))
kernel6(int n, double * restrict w, const double b[n][n])
{
    for (int i = 1; i < n; i++) {
	for (int k = 0; k < i; k++) {
	    w[i] += b[k][i] * w[(i-k)-1];
	}
    }
}

/*
*******************************************************************
*   Kernel 7 -- equation of state fragment
*******************************************************************
*    DO 7 L= 1,Loop
*    DO 7 k= 1,n
*      X(k)=     U(k  ) + R*( Z(k  ) + R*Y(k  )) +
*   .        T*( U(k+3) + R*( U(k+2) + R*U(k+1)) +
*   .        T*( U(k+6) + R*( U(k+5) + R*U(k+4))))
*  7 CONTINUE
*/

void __attribute__ ((noinline))
kernel7(int n, double t, double r,
	double * restrict x, const double * u,
	const double * y, const double * z)
{
    /*#pragma nohazard*/
    for (int k = 0; k < n; k++) {
	x[k] = u[k] + r*( z[k] + r*y[k] ) +
	    t*( u[k+3] + r*( u[k+2] + r*u[k+1] ) +
		t*( u[k+6] + r*( u[k+5] + r*u[k+4] ) ) );
    }
}

/*
*******************************************************************
*   Kernel 8 -- ADI integration
*******************************************************************
*    DO  8      L = 1,Loop
*             nl1 = 1
*             nl2 = 2
*    DO  8     kx = 2,3
*  CDIR$ IVDEP
*    DO  8     ky = 2,n
*          DU1(ky)=U1(kx,ky+1,nl1)  -  U1(kx,ky-1,nl1)
*          DU2(ky)=U2(kx,ky+1,nl1)  -  U2(kx,ky-1,nl1)
*          DU3(ky)=U3(kx,ky+1,nl1)  -  U3(kx,ky-1,nl1)
*    U1(kx,ky,nl2)=U1(kx,ky,nl1) +A11*DU1(ky) +A12*DU2(ky) +A13*DU3(ky)
*   .       + SIG*(U1(kx+1,ky,nl1) -2.*U1(kx,ky,nl1) +U1(kx-1,ky,nl1))
*    U2(kx,ky,nl2)=U2(kx,ky,nl1) +A21*DU1(ky) +A22*DU2(ky) +A23*DU3(ky)
*   .       + SIG*(U2(kx+1,ky,nl1) -2.*U2(kx,ky,nl1) +U2(kx-1,ky,nl1))
*    U3(kx,ky,nl2)=U3(kx,ky,nl1) +A31*DU1(ky) +A32*DU2(ky) +A33*DU3(ky)
*   .       + SIG*(U3(kx+1,ky,nl1) -2.*U3(kx,ky,nl1) +U3(kx-1,ky,nl1))
*  8 CONTINUE
*/

/* u123[2][101][5] */

void __attribute__ ((noinline))
kernel8(int n, double sig,
	double a11, double a12, double a13,
	double a21, double a22, double a23,
	double a31, double a32, double a33,
	double u1[2][n+1][5], double u2[2][n+1][5], double u3[2][n+1][5],
	double * restrict du1, double * restrict du2, double * restrict du3)
{
    int nl1 = 0;
    int nl2 = 1;
    for (int kx = 1; kx < 3; kx++) {
	/*#pragma nohazard*/
	for (int ky = 1; ky < n; ky++) {
	    du1[ky] = u1[nl1][ky+1][kx] - u1[nl1][ky-1][kx];
	    du2[ky] = u2[nl1][ky+1][kx] - u2[nl1][ky-1][kx];
	    du3[ky] = u3[nl1][ky+1][kx] - u3[nl1][ky-1][kx];
	    u1[nl2][ky][kx] =
		u1[nl1][ky][kx]+a11*du1[ky]+a12*du2[ky]+a13*du3[ky] + sig*
		(u1[nl1][ky][kx+1]-2.0*u1[nl1][ky][kx]+u1[nl1][ky][kx-1]);
	    u2[nl2][ky][kx] =
		u2[nl1][ky][kx]+a21*du1[ky]+a22*du2[ky]+a23*du3[ky] + sig*
		(u2[nl1][ky][kx+1]-2.0*u2[nl1][ky][kx]+u2[nl1][ky][kx-1]);
	    u3[nl2][ky][kx] =
		u3[nl1][ky][kx]+a31*du1[ky]+a32*du2[ky]+a33*du3[ky] + sig*
		(u3[nl1][ky][kx+1]-2.0*u3[nl1][ky][kx]+u3[nl1][ky][kx-1]);
	}
    }
}

/*
*******************************************************************
*   Kernel 9 -- integrate predictors
*******************************************************************
*    DO 9  L = 1,Loop
*    DO 9  i = 1,n
*    PX( 1,i)= DM28*PX(13,i) + DM27*PX(12,i) + DM26*PX(11,i) +
*   .          DM25*PX(10,i) + DM24*PX( 9,i) + DM23*PX( 8,i) +
*   .          DM22*PX( 7,i) +  C0*(PX( 5,i) +      PX( 6,i))+ PX( 3,i)
*  9 CONTINUE
*/

/* px[101][25] */

void __attribute__ ((noinline))
kernel9(int n, double dm22, double dm23, double dm24, double dm25,
	double dm26, double dm27, double dm28, double c0,
	double px[n+1][25])
{
    for (int i = 0; i < n; i++) {
	px[i][0] = dm28*px[i][12] + dm27*px[i][11] + dm26*px[i][10] +
	    dm25*px[i][ 9] + dm24*px[i][ 8] + dm23*px[i][ 7] +
	    dm22*px[i][ 6] + c0*( px[i][ 4] + px[i][ 5]) + px[i][ 2];
    }
}

/*
*******************************************************************
*   Kernel 10 -- difference predictors
*******************************************************************
*    DO 10  L= 1,Loop
*    DO 10  i= 1,n
*    AR      =      CX(5,i)
*    BR      = AR - PX(5,i)
*    PX(5,i) = AR
*    CR      = BR - PX(6,i)
*    PX(6,i) = BR
*    AR      = CR - PX(7,i)
*    PX(7,i) = CR
*    BR      = AR - PX(8,i)
*    PX(8,i) = AR
*    CR      = BR - PX(9,i)
*    PX(9,i) = BR
*    AR      = CR - PX(10,i)
*    PX(10,i)= CR
*    BR      = AR - PX(11,i)
*    PX(11,i)= AR
*    CR      = BR - PX(12,i)
*    PX(12,i)= BR
*    PX(14,i)= CR - PX(13,i)
*    PX(13,i)= CR
* 10 CONTINUE
*/

/* cx,px[101][25] */

void __attribute__ ((noinline))
kernel10(int n, double cx[n+1][25], double px[n+1][25])
{
    for (int i = 0; i < n; i++) {
	double ar, br, cr;
	ar        =      cx[i][ 4];
	br        = ar - px[i][ 4];
	px[i][ 4] = ar;
	cr        = br - px[i][ 5];
	px[i][ 5] = br;
	ar        = cr - px[i][ 6];
	px[i][ 6] = cr;
	br        = ar - px[i][ 7];
	px[i][ 7] = ar;
	cr        = br - px[i][ 8];
	px[i][ 8] = br;
	ar        = cr - px[i][ 9];
	px[i][ 9] = cr;
	br        = ar - px[i][10];
	px[i][10] = ar;
	cr        = br - px[i][11];
	px[i][11] = br;
	px[i][13] = cr - px[i][12];
	px[i][12] = cr;
    }
}

/*
*******************************************************************
*   Kernel 11 -- first sum
*******************************************************************
*    DO 11 L = 1,Loop
*        X(1)= Y(1)
*    DO 11 k = 2,n
* 11     X(k)= X(k-1) + Y(k)
*/

void __attribute__ ((noinline))
kernel11(int n, double * restrict x, const double *y)
{
    x[0] = y[0];
    for (int k = 1; k < n; k++) {
	x[k] = x[k-1] + y[k];
    }
}

/*
*******************************************************************
*   Kernel 12 -- first difference
*******************************************************************
*    DO 12 L = 1,Loop
*    DO 12 k = 1,n
* 12     X(k)= Y(k+1) - Y(k)
*/

void __attribute__ ((noinline))
kernel12(int n, double * restrict x, const double *y)
{
    for (int k = 0; k < n; k++) {
	x[k] = y[k+1] - y[k];
    }
}

/*
*******************************************************************
*   Kernel 13 -- 2-D PIC (Particle In Cell)
*******************************************************************
*    DO  13     L= 1,Loop
*    DO  13    ip= 1,n
*              i1= P(1,ip)
*              j1= P(2,ip)
*              i1=        1 + MOD2N(i1,64)
*              j1=        1 + MOD2N(j1,64)
*         P(3,ip)= P(3,ip)  + B(i1,j1)
*         P(4,ip)= P(4,ip)  + C(i1,j1)
*         P(1,ip)= P(1,ip)  + P(3,ip)
*         P(2,ip)= P(2,ip)  + P(4,ip)
*              i2= P(1,ip)
*              j2= P(2,ip)
*              i2=            MOD2N(i2,64)
*              j2=            MOD2N(j2,64)
*         P(1,ip)= P(1,ip)  + Y(i2+32)
*         P(2,ip)= P(2,ip)  + Z(j2+32)
*              i2= i2       + E(i2+32)
*              j2= j2       + F(j2+32)
*        H(i2,j2)= H(i2,j2) + 1.0
* 13 CONTINUE
*/

void __attribute__ ((noinline))
kernel13(int n, double h[64][64], double p[n][4],
	 double b[64][64], double c[64][64],
	 double y[64+32], double z[64+32],
	 long e[64+32], long f[64+32])
{
    for (int ip = 0; ip < n; ip++) {
	long i1, j1;
	i1 = (long)p[ip][0];
	j1 = (long)p[ip][1];
	i1 &= 64-1;
	j1 &= 64-1;
	p[ip][2] += b[j1][i1];
	p[ip][3] += c[j1][i1];
	p[ip][0] += p[ip][2];
	p[ip][1] += p[ip][3];
	long i2, j2;
	i2 = p[ip][0];
	j2 = p[ip][1];
	i2 = (i2 & (64-1)) - 1;
	j2 = (j2 & (64-1)) - 1;
	p[ip][0] += y[i2+32];
	p[ip][1] += z[j2+32];
	i2 += e[i2+32];
	j2 += f[j2+32];
	h[j2][i2] += 1.0;
    }
}

/*
*******************************************************************
*   Kernel 14 -- 1-D PIC (Particle In Cell)
*******************************************************************
*    DO   14   L= 1,Loop
*    DO   141  k= 1,n
*          VX(k)= 0.0
*          XX(k)= 0.0
*          IX(k)= INT(  GRD(k))
*          XI(k)= REAL( IX(k))
*         EX1(k)= EX   ( IX(k))
*        DEX1(k)= DEX  ( IX(k))
*41  CONTINUE
*    DO   142  k= 1,n
*          VX(k)= VX(k) + EX1(k) + (XX(k) - XI(k))*DEX1(k)
*          XX(k)= XX(k) + VX(k)  + FLX
*          IR(k)= XX(k)
*          RX(k)= XX(k) - IR(k)
*          IR(k)= MOD2N(  IR(k),2048) + 1
*          XX(k)= RX(k) + IR(k)
*42  CONTINUE
*    DO  14    k= 1,n
*    RH(IR(k)  )= RH(IR(k)  ) + 1.0 - RX(k)
*    RH(IR(k)+1)= RH(IR(k)+1) + RX(k)
*14  CONTINUE
*/

void __attribute__ ((noinline))
kernel14(int n, double flx, double * restrict rh,
	 const long * grd, const double * ex, const double * dex)
{
    double vx[n];
    double xx[n];
    double xi[n];
    long ix[n];
    double ex1[n];
    double dex1[n];

    double rx[n];
    long ir[n];

    for (int k = 0; k < n; k++) {
	vx[k] = 0.0;
	xx[k] = 0.0;
	ix[k] = (long) grd[k];
	xi[k] = (double) ix[k];
	ex1[k] = ex[ ix[k] - 1 ];
	dex1[k] = dex[ ix[k] - 1 ];
    }
    for (int k = 0; k < n; k++) {
	vx[k] = vx[k] + ex1[k] + ( xx[k] - xi[k] )*dex1[k];
	xx[k] = xx[k] + vx[k]  + flx;
	ir[k] = xx[k];
	rx[k] = xx[k] - ir[k];
	ir[k] = ( ir[k] & (2048-1) ) + 1;
	xx[k] = rx[k] + ir[k];
    }
    for (int k = 0; k < n; k++) {
	rh[ ir[k]-1 ] += 1.0 - rx[k];
	rh[ ir[k]   ] += rx[k];
    }
}

/*
*******************************************************************
*   Kernel 15 -- Casual Fortran.  Development version
*******************************************************************
*      DO 45  L = 1,Loop
*             NG= 7
*             NZ= n
*             AR= 0.053
*             BR= 0.073
* 15   DO 45  j = 2,NG
*      DO 45  k = 2,NZ
*             IF( j-NG) 31,30,30
* 30     VY(k,j)= 0.0
*                 GO TO 45
* 31          IF( VH(k,j+1) -VH(k,j)) 33,33,32
* 32           T= AR
*                 GO TO 34
* 33           T= BR
* 34          IF( VF(k,j) -VF(k-1,j)) 35,36,36
* 35           R= MAX( VH(k-1,j), VH(k-1,j+1))
*              S= VF(k-1,j)
*                 GO TO 37
* 36           R= MAX( VH(k,j),   VH(k,j+1))
*              S= VF(k,j)
* 37     VY(k,j)= SQRT( VG(k,j)**2 +R*R)*T/S
* 38          IF( k-NZ) 40,39,39
* 39     VS(k,j)= 0.
*                 GO TO 45
* 40          IF( VF(k,j) -VF(k,j-1)) 41,42,42
* 41           R= MAX( VG(k,j-1), VG(k+1,j-1))
*              S= VF(k,j-1)
*              T= BR
*                 GO TO 43
* 42           R= MAX( VG(k,j),   VG(k+1,j))
*              S= VF(k,j)
*              T= AR
* 43     VS(k,j)= SQRT( VH(k,j)**2 +R*R)*T/S
* 45    CONTINUE
*/

//extern double sqrt(double);

void __attribute__ ((noinline))
kernel15(int n, double vy[7][n],
	 double vf[7][n], double vg[7][n+1],
	 double vh[7+1][n], double vs[7][n])
{
    /*#pragma intrinsic sqrt*/
    int ng = 7;
    int nz = n;
    double ar = 0.053;
    double br = 0.073;
    double r, s, t;
    for (int j = 1; j < ng; j++) {
	for (int k = 1; k < nz; k++) {
	    if ( (j+1) >= ng ) {
		vy[j][k] = 0.0;
		continue;
	    }
	    if ( vh[j+1][k] > vh[j][k] ) {
		t = ar;
	    } else {
		t = br;
	    }
	    if ( vf[j][k] < vf[j][k-1] ) {
		if ( vh[j][k-1] > vh[j+1][k-1] ) {
		    r = vh[j][k-1];
		} else {
		    r = vh[j+1][k-1];
		}
		s = vf[j][k-1];
	    } else {
		if ( vh[j][k] > vh[j+1][k] ) {
		    r = vh[j][k];
		} else {
		    r = vh[j+1][k];
		}
		s = vf[j][k];
	    }
	    vy[j][k] = sqrt( vg[j][k]*vg[j][k] + r*r )* t/s;
	    if ( (k+1) >= nz ) {
		vs[j][k] = 0.0;
		continue;
	    }
	    if ( vf[j][k] < vf[j-1][k] ) {
		if ( vg[j-1][k] > vg[j-1][k+1] ) {
		    r = vg[j-1][k];
		} else {
		    r = vg[j-1][k+1];
		}
		s = vf[j-1][k];
		t = br;
	    } else {
		if ( vg[j][k] > vg[j][k+1] ) {
		    r = vg[j][k];
		} else {
		    r = vg[j][k+1];
		}
		s = vf[j][k];
		t = ar;
	    }
	    vs[j][k] = sqrt( vh[j][k]*vh[j][k] + r*r )* t / s;
	}
    }
}

/*
*******************************************************************
*   Kernel 16 -- Monte Carlo search loop
*******************************************************************
*          II= n/3
*          LB= II+II
*          k2= 0
*          k3= 0
*    DO 485 L= 1,Loop
*           m= 1
*405       i1= m
*410       j2= (n+n)*(m-1)+1
*    DO 470 k= 1,n
*          k2= k2+1
*          j4= j2+k+k
*          j5= ZONE(j4)
*          IF( j5-n      ) 420,475,450
*415       IF( j5-n+II   ) 430,425,425
*420       IF( j5-n+LB   ) 435,415,415
*425       IF( PLAN(j5)-R) 445,480,440
*430       IF( PLAN(j5)-S) 445,480,440
*435       IF( PLAN(j5)-T) 445,480,440
*440       IF( ZONE(j4-1)) 455,485,470
*445       IF( ZONE(j4-1)) 470,485,455
*450       k3= k3+1
*          IF( D(j5)-(D(j5-1)*(T-D(j5-2))**2+(S-D(j5-3))**2
*   .                        +(R-D(j5-4))**2)) 445,480,440
*455        m= m+1
*          IF( m-ZONE(1) ) 465,465,460
*460        m= 1
*465       IF( i1-m) 410,480,410
*470 CONTINUE
*475 CONTINUE
*480 CONTINUE
*485 CONTINUE
*/

/* Returning j4 is uncertain. */

int __attribute__ ((noinline))
kernel16(int n, double s, double t, double r,
	 long zone[300], double plan[300], double d[300])
{
    int ii = n / 3;
    int lb = ii + ii;
    int k2, k3;
    k3 = k2 = 0;

    int i1, m, j2, j4, j5;
    double tmp;

    i1 = m = 1;
    label410:
    j2 = ( n + n )*( m - 1 ) + 1;
    k2 = 0;
    for (int k = 1; k <= n; k++) {
	k2++;
	j4 = j2 + k + k;
	j5 = zone[j4-1];
	if ( j5 < n ) {
	    if ( j5+lb < n ) {              /* 420 */
		tmp = plan[j5-1] - t;       /* 435 */
	    } else {
		if ( j5+ii < n ) {          /* 415 */
		    tmp = plan[j5-1] - s;   /* 430 */
		} else {
		    tmp = plan[j5-1] - r;   /* 425 */
		}
	    }
	} else if( j5 == n ) {
	    break;                          /* 475 */
	} else {
	    k3++;                           /* 450 */
	    tmp=(d[j5-1]-(d[j5-2]*(t-d[j5-3])*(t-d[j5-3])+(s-d[j5-4])*
			  (s-d[j5-4])+(r-d[j5-5])*(r-d[j5-5])));
	}
	if ( tmp < 0.0 ) {
	    if ( zone[j4-2] < 0 )           /* 445 */
		continue;                   /* 470 */
	    else if ( !zone[j4-2] )
		break;                      /* 480 */
	} else if ( tmp ) {
	    if ( zone[j4-2] > 0 )           /* 440 */
		continue;                   /* 470 */
	    else if ( !zone[j4-2] )
		break;                      /* 480 */
	} else break;                       /* 485 */
	m++;                                /* 455 */
	if ( m > zone[0] )
	    m = 1;                          /* 460 */
	if ( i1-m )                         /* 465 */
	    goto label410;
	else
	    break;
    }
    return m;
}

/*
*******************************************************************
*   Kernel 17 -- implicit, conditional computation
*******************************************************************
*          DO 62 L= 1,Loop
*                i= n
*                j= 1
*              INK= -1
*            SCALE= 5./3.
*              XNM= 1./3.
*               E6= 1.03/3.07
*                   GO TO 61
*60             E6= XNM*VSP(i)+VSTP(i)
*          VXNE(i)= E6
*              XNM= E6
*           VE3(i)= E6
*                i= i+INK
*               IF( i.EQ.j) GO TO  62
*61             E3= XNM*VLR(i) +VLIN(i)
*             XNEI= VXNE(i)
*          VXND(i)= E6
*              XNC= SCALE*E3
*               IF( XNM .GT.XNC) GO TO  60
*               IF( XNEI.GT.XNC) GO TO  60
*           VE3(i)= E3
*               E6= E3+E3-XNM
*          VXNE(i)= E3+E3-XNEI
*              XNM= E6
*                i= i+INK
*               IF( i.NE.j) GO TO 61
* 62 CONTINUE
*/

void __attribute__ ((noinline))
kernel17(int n, double vxne[n], double vxnd[n],
	 double vlr[n], double vlin[n],
	 double ve3[n], double vsp[n], double vstp[n])
{
    int i, j, ink;
    double scale, xnm, e3, e6, xnei, xnc;

    i = n-1;
    j = 0;
    ink = -1;
    scale = 5.0 / 3.0;
    xnm = 1.0 / 3.0;
    e6 = 1.03 / 3.07;
    goto l61;
    l60:    e6 = xnm*vsp[i] + vstp[i];
    vxne[i] = e6;
    xnm = e6;
    ve3[i] = e6;
    i += ink;
    if ( i==j ) goto l62;
    l61:    e3 = xnm*vlr[i] + vlin[i];
    xnei = vxne[i];
    vxnd[i] = e6;
    xnc = scale*e3;
    if ( xnm > xnc ) goto l60;
    if ( xnei > xnc ) goto l60;
    ve3[i] = e3;
    e6 = e3 + e3 - xnm;
    vxne[i] = e3 + e3 - xnei;
    xnm = e6;
    i += ink;
    if ( i != j ) goto l61;
    l62:;
}

/*
*******************************************************************
*   Kernel 18 - 2-D explicit hydrodynamics fragment
*******************************************************************
*       DO 75  L= 1,Loop
*              T= 0.0037
*              S= 0.0041
*             KN= 6
*             JN= n
*       DO 70  k= 2,KN
*       DO 70  j= 2,JN
*        ZA(j,k)= (ZP(j-1,k+1)+ZQ(j-1,k+1)-ZP(j-1,k)-ZQ(j-1,k))
*   .            *(ZR(j,k)+ZR(j-1,k))/(ZM(j-1,k)+ZM(j-1,k+1))
*        ZB(j,k)= (ZP(j-1,k)+ZQ(j-1,k)-ZP(j,k)-ZQ(j,k))
*   .            *(ZR(j,k)+ZR(j,k-1))/(ZM(j,k)+ZM(j-1,k))
* 70    CONTINUE
*       DO 72  k= 2,KN
*       DO 72  j= 2,JN
*        ZU(j,k)= ZU(j,k)+S*(ZA(j,k)*(ZZ(j,k)-ZZ(j+1,k))
*   .                    -ZA(j-1,k) *(ZZ(j,k)-ZZ(j-1,k))
*   .                    -ZB(j,k)   *(ZZ(j,k)-ZZ(j,k-1))
*   .                    +ZB(j,k+1) *(ZZ(j,k)-ZZ(j,k+1)))
*        ZV(j,k)= ZV(j,k)+S*(ZA(j,k)*(ZR(j,k)-ZR(j+1,k))
*   .                    -ZA(j-1,k) *(ZR(j,k)-ZR(j-1,k))
*   .                    -ZB(j,k)   *(ZR(j,k)-ZR(j,k-1))
*   .                    +ZB(j,k+1) *(ZR(j,k)-ZR(j,k+1)))
* 72    CONTINUE
*       DO 75  k= 2,KN
*       DO 75  j= 2,JN
*        ZR(j,k)= ZR(j,k)+T*ZU(j,k)
*        ZZ(j,k)= ZZ(j,k)+T*ZV(j,k)
* 75    CONTINUE
*/

/* Constants in KERNEL18 are changed to exactly representable ones for
   testing.  Originally, they are t=0.0037; s=0.0041. */

void __attribute__ ((noinline))
kernel18(int n, double zr[7][n], double zz[7][n],
	 double za[7][n], double zb[7][n],
	 double zp[7][n], double zq[7][n],
	 double zu[7][n], double zv[7][n],
	 double zm[7][n])
{
    double s, t;
    int kn, jn;

    t = 0.00390625;
    s = 0.00390625 + 0.001953125;
    /*t = 0.0037;*/
    /*s = 0.0041;*/
    kn = 6;
    jn = n;
    for (int k = 1; k < kn; k++) {
	/*#pragma nohazard*/
	for (int j = 1; j < jn; j++) {
	    za[k][j] = ( zp[k+1][j-1] +zq[k+1][j-1] -zp[k][j-1] -zq[k][j-1] )*
		( zr[k][j] +zr[k][j-1] ) / ( zm[k][j-1] +zm[k+1][j-1]);
	    zb[k][j] = ( zp[k][j-1] +zq[k][j-1] -zp[k][j] -zq[k][j] )*
		( zr[k][j] +zr[k-1][j] ) / ( zm[k][j] +zm[k][j-1]);
	}
    }
    for (int k = 1; k < kn; k++) {
	/*#pragma nohazard*/
	for (int j = 1; j < jn; j++) {
	    zu[k][j] += s*( za[k][j]   *( zz[k][j] - zz[k][j+1] ) -
			    za[k][j-1] *( zz[k][j] - zz[k][j-1] ) -
			    zb[k][j]   *( zz[k][j] - zz[k-1][j] ) +
			    zb[k+1][j] *( zz[k][j] - zz[k+1][j] ) );
	    zv[k][j] += s*( za[k][j]   *( zr[k][j] - zr[k][j+1] ) -
			    za[k][j-1] *( zr[k][j] - zr[k][j-1] ) -
			    zb[k][j]   *( zr[k][j] - zr[k-1][j] ) +
			    zb[k+1][j] *( zr[k][j] - zr[k+1][j] ) );
	}
    }
    for (int k = 1; k < kn; k++) {
	/*#pragma nohazard*/
	for (int j = 1; j < jn; j++) {
	    zr[k][j] = zr[k][j] + t*zu[k][j];
	    zz[k][j] = zz[k][j] + t*zv[k][j];
	}
    }
}

/*
*******************************************************************
*   Kernel 19 -- general linear recurrence equations
*******************************************************************
*               KB5I= 0
*           DO 194 L= 1,Loop
*           DO 191 k= 1,n
*         B5(k+KB5I)= SA(k) +STB5*SB(k)
*               STB5= B5(k+KB5I) -STB5
*191        CONTINUE
*192        DO 193 i= 1,n
*                  k= n-i+1
*         B5(k+KB5I)= SA(k) +STB5*SB(k)
*               STB5= B5(k+KB5I) -STB5
*193        CONTINUE
*194 CONTINUE
*/

double stb5 = 0;

void __attribute__ ((noinline))
kernel19(int n, double * restrict b5, const double * sa,
	 const double * sb)
{
    int kb5i = 0;

    for (int k = 0; k < n; k++) {
	b5[k+kb5i] = sa[k] + stb5*sb[k];
	stb5 = b5[k+kb5i] - stb5;
    }
    for (int i = 1; i <= n; i++) {
	int k = n - i ;
	b5[k+kb5i] = sa[k] + stb5*sb[k];
	stb5 = b5[k+kb5i] - stb5;
    }
}

/*
*******************************************************************
*   Kernel 20 -- Discrete ordinates transport, conditional recurrence on xx
*******************************************************************
*    DO 20 L= 1,Loop
*    DO 20 k= 1,n
*         DI= Y(k)-G(k)/( XX(k)+DK)
*         DN= 0.2
*         IF( DI.NE.0.0) DN= MAX( S,MIN( Z(k)/DI, T))
*       X(k)= ((W(k)+V(k)*DN)* XX(k)+U(k))/(VX(k)+V(k)*DN)
*    XX(k+1)= (X(k)- XX(k))*DN+ XX(k)
* 20 CONTINUE
*/

void __attribute__ ((noinline))
kernel20(int n, double s, double t, double dk,
	 double * restrict x, double * restrict xx,
	 const double * vx,
	 const double * y, const double * z,
	 const double * g,
	 const double * u, const double * v, const double * w)
{
    double di, dn;

    for (int k = 0; k < n; k++) {
	di = y[k] - g[k] / ( xx[k] + dk );
	dn = 0.2;
	if ( di != 0.0 ) {
	    dn = z[k]/di ;
	    if ( t < dn ) dn = t;
	    if ( s > dn ) dn = s;
	}
	x[k] = ( ( w[k] + v[k]*dn )* xx[k] + u[k] ) / ( vx[k] + v[k]*dn );
	xx[k+1] = ( x[k] - xx[k] )* dn + xx[k];
    }
}

/*
*******************************************************************
*   Kernel 21 -- matrix*matrix product
*******************************************************************
*    DO 21 L= 1,Loop
*    DO 21 k= 1,25
*    DO 21 i= 1,25
*    DO 21 j= 1,n
*    PX(i,j)= PX(i,j) +VY(i,k) * CX(k,j)
* 21 CONTINUE
*/

void __attribute__ ((noinline))
kernel21(int n, double px[n][25], const double vy[25][101],
	 const double cx[n][25])
{
    for (int k = 0; k < 25; k++) {
	for (int i = 0; i < 25; i++) {
	    /*#pragma nohazard*/
	    for (int j = 0; j < n; j++) {
		px[j][i] += vy[k][i] * cx[j][k];
	    }
	}
    }
}

/*
*******************************************************************
*   Kernel 22 -- Planckian distribution
*******************************************************************
*     EXPMAX= 20.0
*       U(n)= 0.99*EXPMAX*V(n)
*    DO 22 L= 1,Loop
*    DO 22 k= 1,n
*                                          Y(k)= U(k)/V(k)
*       W(k)= X(k)/( EXP( Y(k)) -1.0)
* 22 CONTINUE
*/

void __attribute__ ((noinline))
kernel22(int n, double * restrict w, const double * x,
	 double * restrict u, const double * v)
{
    double expmax;

    /*#pragma intrinsic exp*/
    expmax = 20.0;
    u[n-1] = 0.99*expmax*v[n-1];

    double y[n];

    for (int k = 0; k < n; k++) {
	y[k] = u[k] / v[k];
	w[k] = x[k] / ( exp( y[k] ) -1.0 );
    }
}

/*
*******************************************************************
*   Kernel 23 -- 2-D implicit hydrodynamics fragment
*******************************************************************
*    DO 23  L= 1,Loop
*    DO 23  j= 2,6
*    DO 23  k= 2,n
*          QA= ZA(k,j+1)*ZR(k,j) +ZA(k,j-1)*ZB(k,j) +
*   .          ZA(k+1,j)*ZU(k,j) +ZA(k-1,j)*ZV(k,j) +ZZ(k,j)
* 23  ZA(k,j)= ZA(k,j) +.175*(QA -ZA(k,j))
*/

void __attribute__ ((noinline))
kernel23(int n, double za[7][n+1], double zb[7][n+1],
	 double zr[7][n+1], double zu[7][n+1],
	 double zv[7][n+1], double zz[7][n+1])
{
    double qa;
    for (int j = 1; j < 6; j++) {
	for (int k = 1; k < n; k++) {
	    qa = za[j+1][k]*zr[j][k] + za[j-1][k]*zb[j][k] +
		za[j][k+1]*zu[j][k] + za[j][k-1]*zv[j][k] + zz[j][k];
	    za[j][k] += 0.175*( qa - za[j][k] );
	}
    }
}

/*
*******************************************************************
*   Kernel 24 -- find location of first minimum in array
*******************************************************************
*     X( n/2)= -1.0E+10
*    DO 24  L= 1,Loop
*           m= 1
*    DO 24  k= 2,n
*          IF( X(k).LT.X(m))  m= k
* 24 CONTINUE
*/

int __attribute__ ((noinline))
kernel24(int n, double * x)
{
    x[n/2] = -1.0e+10;

    int m;
    m = 0;
    for (int k = 1 ; k < n ; k++) {
	if ( x[k] < x[m] ) m = k;
    }
    return m;
}

/* See "SUBROUTINE VALUES(i)" and "SUPPLY(i)" for data initlization in
   the fortran version. */

/*
 *            DS= 1.000d0
 *            DW= 0.500d0
 *      DO 205 j= 1,4
 *      DO 205 k= 1,512
 *      P(j,k)  = DS
 *      P0(j,k) = DS
 *            DS= DS + DW
 *  205 CONTINUE
 *      DO 210 j= 1,96
 *      E(j) = 1
 *      F(j) = 1
 *  210 CONTINUE
 */

void
init13(int n, double p[n][4], double p0[n][4],
       long e[64+32], long f[64+32])
{
    double ds;
    ds = 1.000e0;
    double dw = 0.500e0;
    for (int j = 0; j < 4; j++) {
	for (int k = 0; k < 512; k++) {
	    p[k][j] = ds;
	    p0[k][j] = ds;
	    ds = ds + dw;
	}
    }
    for (int i = 0; i < 96; i++) {
	e[i] = 1;
	f[i] = 1;
    }
}

int IQRANF_k;

void
IQRAN0(int newk)
{
    IQRANF_k = newk;
}

/* Computes a vector of psuedo-random indices (n integers) in the
   domain [Mmin,Mmax]. */

void
IQRANF(int n, int M[n], int Mmin, int Mmax)
{
    if (n > 0) {
	int inset = Mmin;
	double span = Mmax - Mmin;
	double spin = 16807;
	double per = 2147483647;
	double realn = n;
	double scale = 1.0000100e0;
	double q = scale*(span/realn);
	double dk = IQRANF_k;
	for (int i = 0; i < n; i++) {
            double dp = dk*spin;
	    double dk = dp - (int)(dp/per)*per;
	    double dq = dk*span;
	    M[i]= inset + (dq/per);
	    if (M[i] < Mmin || M[i] > Mmax ) {
		M[i] = inset + i*q;
	    }
	}
	IQRANF_k = dk;
    }
}

/*
 *      mmin= 1
 *      mmax= 1001
 *      CALL IQRANF( IX, mmin, mmax, 1001)
 *            DW= -100.000d0
 *      DO 215 J= 1,1001
 *      DEX(J) =  DW*DEX(J)
 *      GRD(J) = IX(J)
 *  215 CONTINUE
 *      FLX= 0.00100d0
 */

void
init14(double *flx_, int ix[1001], double dex[1001], double grd[1001])
{
    int mmin = 1;
    int mmax = 1001;
    IQRANF(1001, ix, mmin, mmax);
    double dw = -100.000e0;
    for (int j = 0; j < 1001; j++) {
	dex[j] = dw*dex[j];
	grd[j] = ix[j];
    }
    *flx_ = 0.00100e0;
}

/*
 *cONDITIONS:
 *            MC= 2
 *            lr= n
 *            II= lr/3
 *            FW= 1.000d-4
 *          D(1)= 1.0198048642876400d0
 *      DO 400 k= 2,300
 *  400     D(k)= D(k-1) + FW/D(k-1)
 *             R= D(lr)
 *            FW= 1.000d0
 *      DO 403 LX= 1,MC
 *             m= (lr+lr)*(LX-1)
 *      DO 401 j= 1,2
 *      DO 401 k= 1,lr
 *             m= m+1
 *             S= REAL(k)
 *       PLAN(m)= R*((S + FW)/S)
 *  401  ZONE(m)= k+k
 *  403 CONTINUE
 *             k= lr+lr+1
 *       ZONE(k)= lr
 *             S= D(lr-1)
 *             T= D(lr-2)
 *c
 *   50 CONTINUE
 *c               Clear the scalar Cache-memory with never used data-set.
 *c     fw= 1.000d0
 *c     CALL SIGNEL( CACHE, fw, 0.0d0, 8192)
 *c
 *             j= 0
 *            sc= 0.0d0
 *      DO 777 k= 1,8192
 *            IF( CACHE(k).EQ. 0.0)  THEN
 *             j= j + k
 *            sc= sc + REAL(j*k)
 *            ENDIF
 *  777 CONTINUE
 */

void
init16(int n, int *ii_, double *s_, double *t_,
       double d[n], double zone[2*n*2], double plan[2*n*2])
{
    assert(n >= 300);
    int mc = 2;
    int lr = n;
    *ii_ = lr/3;
    double fw;
    fw = 1.000e-4;
    d[0] = 1.0198048642876400e0;
    for (int k = 1; k < 300; k++) {
	d[k] = d[k-1] + fw/d[k-1];
    }
    double r = d[lr];
    fw = 1.000e0;
    for (int lx = 0; lx < mc; lx++) {
	int m;
	m = (lr+lr)*lx;
	for (int j = 0; j < 2; j++) {
	    for (int k = 0; k < lr; k++) {
		m = m+1;
		double s = (double)(k+1);
		plan[m - 1] = r*((s + fw)/s);
		zone[m - 1] = (k+1)+(k+1);
	    }
	}
    }
    int k = lr+lr+1;
    zone[k - 1] = lr;
    *s_ = d[lr-1 - 1];
    *t_ = d[lr-2 - 1];
}

static double
serial3(int n, const double * x, const double * z)
{
    double q;
    q = 0.0;
    for (int k = 0; k < n; k++) {
	assert(one == 1);
	q += z[k]*x[k];
    }
    return q;
}

static void __attribute__ ((noinline))
serial4(int n, double * restrict x, const double * y, const double * xz)
{
    int m = ( 1001 - 7 )/2;
    for (int k = 6; k < 1001; k = k + m) {
	int lw = k - 6;
	double temp = xz[k-1];
	/*#pragma nohazard*/
	for (int j = 4; j < n; j = j + 5) {
	    assert(one == 1);
	    temp -= xz[lw]*y[j];
	    lw++;
	}
	x[k-1] = y[4]*temp;
    }
}

static void
serial8(int n, double sig,
	double a11, double a12, double a13,
	double a21, double a22, double a23,
	double a31, double a32, double a33,
	double u1[2][n+1][5], double u2[2][n+1][5], double u3[2][n+1][5],
	double * restrict du1, double * restrict du2, double * restrict du3)
{
    int nl1 = 0;
    int nl2 = 1;
    for (int kx = 1; kx < 3; kx++) {
	/*#pragma nohazard*/
	for (int ky = 1; ky < n; ky++) {
	    assert(one == 1);
	    du1[ky] = u1[nl1][ky+1][kx] - u1[nl1][ky-1][kx];
	    du2[ky] = u2[nl1][ky+1][kx] - u2[nl1][ky-1][kx];
	    du3[ky] = u3[nl1][ky+1][kx] - u3[nl1][ky-1][kx];
	    u1[nl2][ky][kx] =
		u1[nl1][ky][kx]+a11*du1[ky]+a12*du2[ky]+a13*du3[ky] + sig*
		(u1[nl1][ky][kx+1]-2.0*u1[nl1][ky][kx]+u1[nl1][ky][kx-1]);
	    u2[nl2][ky][kx] =
		u2[nl1][ky][kx]+a21*du1[ky]+a22*du2[ky]+a23*du3[ky] + sig*
		(u2[nl1][ky][kx+1]-2.0*u2[nl1][ky][kx]+u2[nl1][ky][kx-1]);
	    u3[nl2][ky][kx] =
		u3[nl1][ky][kx]+a31*du1[ky]+a32*du2[ky]+a33*du3[ky] + sig*
		(u3[nl1][ky][kx+1]-2.0*u3[nl1][ky][kx]+u3[nl1][ky][kx-1]);
	}
    }
}

static void
serial9(int n, double dm22, double dm23, double dm24, double dm25,
	double dm26, double dm27, double dm28, double c0,
	double px[n+1][25])
{
    for (int i = 0; i < n; i++) {
	assert(one == 1);
	px[i][0] = dm28*px[i][12] + dm27*px[i][11] + dm26*px[i][10] +
	    dm25*px[i][ 9] + dm24*px[i][ 8] + dm23*px[i][ 7] +
	    dm22*px[i][ 6] + c0*( px[i][ 4] + px[i][ 5]) + px[i][ 2];
    }
}

static void
serial10(int n, double cx[n+1][25], double px[n+1][25])
{
    for (int i = 0; i < n; i++) {
	assert(one == 1);
	double ar, br, cr;
	ar        =      cx[i][ 4];
	br        = ar - px[i][ 4];
	px[i][ 4] = ar;
	cr        = br - px[i][ 5];
	px[i][ 5] = br;
	ar        = cr - px[i][ 6];
	px[i][ 6] = cr;
	br        = ar - px[i][ 7];
	px[i][ 7] = ar;
	cr        = br - px[i][ 8];
	px[i][ 8] = br;
	ar        = cr - px[i][ 9];
	px[i][ 9] = cr;
	br        = ar - px[i][10];
	px[i][10] = ar;
	cr        = br - px[i][11];
	px[i][11] = br;
	px[i][13] = cr - px[i][12];
	px[i][12] = cr;
    }
}

static void
serial12(int n, double * restrict x, const double *y)
{
    for (int k = 0; k < n; k++) {
	assert(one == 1);
	x[k] = y[k+1] - y[k];
    }
}

static void
serial14(int n, double flx, double * restrict rh,
	 const long * grd, const double * ex, const double * dex)
{
    double vx[n];
    double xx[n];
    double xi[n];
    long ix[n];
    double ex1[n];
    double dex1[n];

    double rx[n];
    long ir[n];

    for (int k = 0; k < n; k++) {
	assert(one == 1);
	vx[k] = 0.0;
	xx[k] = 0.0;
	ix[k] = (long) grd[k];
	xi[k] = (double) ix[k];
	ex1[k] = ex[ ix[k] - 1 ];
	dex1[k] = dex[ ix[k] - 1 ];
    }
    for (int k = 0; k < n; k++) {
	assert(one == 1);
	vx[k] = vx[k] + ex1[k] + ( xx[k] - xi[k] )*dex1[k];
	xx[k] = xx[k] + vx[k]  + flx;
	ir[k] = xx[k];
	rx[k] = xx[k] - ir[k];
	ir[k] = ( ir[k] & (2048-1) ) + 1;
	xx[k] = rx[k] + ir[k];
    }
    for (int k = 0; k < n; k++) {
	assert(one == 1);
	rh[ ir[k]-1 ] += 1.0 - rx[k];
	rh[ ir[k]   ] += rx[k];
    }
}

static void
serial18(int n, double zr[7][n], double zz[7][n],
	 double za[7][n], double zb[7][n],
	 double zp[7][n], double zq[7][n],
	 double zu[7][n], double zv[7][n],
	 double zm[7][n])
{
    double s, t;
    int kn, jn;

    t = 0.00390625;
    s = 0.00390625 + 0.001953125;
    /*t = 0.0037;*/
    /*s = 0.0041;*/
    kn = 6;
    jn = n;
    for (int k = 1; k < kn; k++) {
	/*#pragma nohazard*/
	for (int j = 1; j < jn; j++) {
	    assert(one == 1);
	    za[k][j] = ( zp[k+1][j-1] +zq[k+1][j-1] -zp[k][j-1] -zq[k][j-1] )*
		( zr[k][j] +zr[k][j-1] ) / ( zm[k][j-1] +zm[k+1][j-1]);
	    zb[k][j] = ( zp[k][j-1] +zq[k][j-1] -zp[k][j] -zq[k][j] )*
		( zr[k][j] +zr[k-1][j] ) / ( zm[k][j] +zm[k][j-1]);
	}
    }
    for (int k = 1; k < kn; k++) {
	/*#pragma nohazard*/
	for (int j = 1; j < jn; j++) {
	    assert(one == 1);
	    zu[k][j] += s*( za[k][j]   *( zz[k][j] - zz[k][j+1] ) -
			    za[k][j-1] *( zz[k][j] - zz[k][j-1] ) -
			    zb[k][j]   *( zz[k][j] - zz[k-1][j] ) +
			    zb[k+1][j] *( zz[k][j] - zz[k+1][j] ) );
	    zv[k][j] += s*( za[k][j]   *( zr[k][j] - zr[k][j+1] ) -
			    za[k][j-1] *( zr[k][j] - zr[k][j-1] ) -
			    zb[k][j]   *( zr[k][j] - zr[k-1][j] ) +
			    zb[k+1][j] *( zr[k][j] - zr[k+1][j] ) );
	}
    }
    for (int k = 1; k < kn; k++) {
	/*#pragma nohazard*/
	for (int j = 1; j < jn; j++) {
	    assert(one == 1);
	    zr[k][j] = zr[k][j] + t*zu[k][j];
	    zz[k][j] = zz[k][j] + t*zv[k][j];
	}
    }
}

static void
serial21(int n, double px[n][25], const double vy[25][101],
	 const double cx[n][25])
{
    for (int k = 0; k < 25; k++) {
	for (int i = 0; i < 25; i++) {
	    /*#pragma nohazard*/
	    for (int j = 0; j < n; j++) {
		assert(one == 1);
		px[j][i] += vy[k][i] * cx[j][k];
	    }
	}
    }
}

const int N9 = 100;
const int N10 = 100;
const int N12 = 1000;
const int N14 = 1000;
const int N18 = 100;
const int N21 = 100;

double space2_u1[2][101][5];
double space2_u2[2][101][5];
double space2_u3[2][101][5];
double space1_du1[101];
double space1_du2[101];
double space1_du3[101];

double spaceA_u1[2][101][5];
double spaceA_u2[2][101][5];
double spaceA_u3[2][101][5];
double spaceA_du1[101];
double spaceA_du2[101];
double spaceA_du3[101];

double space2_px[101][25];
double spaceA_px[101][25];

double space2_cx[101][25];
double spaceA_cx[101][25];

double space1_x[1001];
double space1_y[1001];
double space1_z[1001];
double spaceA_x[1001];
double spaceA_y[1001];

double space1_xz[1500];

double space1_ex[1001];
double space1_dex[1001];
long space1_grd[1001];
double space1_rh[2048];
double spaceA_rh[2048];

double space2_za[7][101];
double space2_zb[7][101];
double space2_zm[7][101];
double space2_zp[7][101];
double space2_zq[7][101];
double space2_zr[7][101];
double space2_zu[7][101];
double space2_zv[7][101];
double space2_zz[7][101];

double spaceA_za[7][101];
double spaceA_zb[7][101];
double spaceA_zm[7][101];
double spaceA_zp[7][101];
double spaceA_zq[7][101];
double spaceA_zr[7][101];
double spaceA_zu[7][101];
double spaceA_zv[7][101];
double spaceA_zz[7][101];

double space2_vy[25][101];

int
main(int argc, char **argv)
{
    one = 1;

    _Bool kernel3_ = 0;
    _Bool kernel4_ = 0;
    _Bool kernel8_ = 0;
    _Bool kernel9_ = 0;
    _Bool kernel10_ = 0;
    _Bool kernel12_ = 0;
    _Bool kernel14_ = 0;
    _Bool kernel18_ = 0;
    _Bool kernel21_ = 1;

    /* kernel3 */

    if (kernel3_) {
	int N3 = 1001;
	for (int i = 0; i < N3; i++) {
	    space1_x[i] = i + 5;
	    space1_z[i] = i + 7;
	}
	double v3 = kernel3(N3, space1_x, space1_z);
	double q3 = serial3(N3, space1_x, space1_z);
	/*printf("q3=%e v3=%e\n", q3, v3);*/
	assert(q3 == v3);
    }

    /* kernel4 */

    if (kernel4_) {
	int N4 = 1001;
	for (int i = 0; i < N4; i++) {
	    //assert(one);
	    space1_x[i] = 0;
	    spaceA_x[i] = 0;
	    space1_y[i] = 1;
	}
	for (int i = 0; i < 1500; i++) {
	    space1_xz[i] = 1;
	}
	kernel4(N4, space1_x, space1_y, space1_xz);
	serial4(N4, spaceA_x, space1_y, space1_xz);
	for (int i = 0; i < N4; i++) {
#if 0
	    printf("spaceA_x[i]=%e space1_x[i]=%e\n",
		   spaceA_x[i], space1_x[i]);
#endif
	    assert(spaceA_x[i] == space1_x[i]);
	}
    }

    /* kernel8 */

    if (kernel8_) {
	int N8 = 101;
	for (int i = 0; i < N8; i++) {
	    for (int j = 0; j < 5; j++) {
		for (int k = 0; k < 2; k++) {
		    space2_u1[k][i][j] = (5 * i + j);
		    space2_u2[k][i][j] = (7 * i + j);
		    space2_u3[k][i][j] = (11 * i + j);
		    spaceA_u1[k][i][j] = (5 * i + j);
		    spaceA_u2[k][i][j] = (7 * i + j);
		    spaceA_u3[k][i][j] = (11 * i + j);
		}
	    }
	    space1_du1[i] = 0;
	    space1_du2[i] = 0;
	    space1_du3[i] = 0;
	    spaceA_du1[i] = 0;
	    spaceA_du2[i] = 0;
	    spaceA_du3[i] = 0;
	}
	kernel8(N8, 3.0, 5.0, 7.0, 11.0, 13.0, 17.0, 19.0, 23.0, 29.0, 31.0,
		space2_u1, space2_u2, space2_u3,
		space1_du1, space1_du2, space1_du3);
	serial8(N8, 3.0, 5.0, 7.0, 11.0, 13.0, 17.0, 19.0, 23.0, 29.0, 31.0,
		spaceA_u1, spaceA_u2, spaceA_u3,
		spaceA_du1, spaceA_du2, spaceA_du3);
	for (int i = 0; i < N8; i++) {
	    for (int j = 0; j < 5; j++) {
		for (int k = 0; k < 2; k++) {
#if 0
		    printf("spaceA_u1=%e space2_u1=%e\n"
			   "spaceA_u1=%e space2_u1=%e\n"
			   "spaceA_u1=%e space2_u1=%e\n",
			   spaceA_u1[k][i][j], space2_u1[k][i][j],
			   spaceA_u2[k][i][j], space2_u2[k][i][j],
			   spaceA_u3[k][i][j], space2_u3[k][i][j]);
#endif
		    assert(spaceA_u1[k][i][j] == space2_u1[k][i][j]
			   && spaceA_u2[k][i][j] == space2_u2[k][i][j]
			   && spaceA_u3[k][i][j] == space2_u3[k][i][j]);
		}
	    }
	}
    }

    /* kernel9 */

    if (kernel9_) {
	double dm22 = 22;
	double dm23 = 23;
	double dm24 = 24;
	double dm25 = 25;
	double dm26 = 26;
	double dm27 = 27;
	double dm28 = 28;
	double c0 = 29;
	for (int j = 0; j < (N9 + 1); j++) {
	    for (int i = 0; i < 25; i++) {
		space2_px[j][i] = ((j + 3) * 25) + (i + 5);
		spaceA_px[j][i] = ((j + 3) * 25) + (i + 5);
	    }
	}
	kernel9(N9, dm22, dm23, dm24, dm25, dm26, dm27, dm28, c0, space2_px);
	serial9(N9, dm22, dm23, dm24, dm25, dm26, dm27, dm28, c0, spaceA_px);
	for (int j = 0; j < (N9 + 1); j++) {
	    for (int i = 0; i < 25; i++) {
#if 0
		printf("spaceA_px[%d][%d]=%e space2_px[%d][%d]=%e\n",
		       j, i, spaceA_px[j][i], j, i, space2_px[j][i]);
#endif
		assert(spaceA_px[j][i] == space2_px[j][i]);
	    }
	}
    }

    /* kernel10 */

    if (kernel10_) {
	for (int j = 0; j < (N10 + 1); j++) {
	    for (int i = 0; i < 25; i++) {
		space2_cx[j][i] = ((j + 3) * 25) + (i + 7);
		spaceA_cx[j][i] = ((j + 3) * 25) + (i + 7);
		space2_px[j][i] = ((j + 5) * 25) + (i + 11);
		spaceA_px[j][i] = ((j + 5) * 25) + (i + 11);
	    }
	}
	kernel10(N10, space2_cx, space2_px);
	serial10(N10, spaceA_cx, spaceA_px);
	for (int j = 0; j < (N10 + 1); j++) {
	    for (int i = 0; i < 25; i++) {
		/*printf("spaceA_cx[j][i]=%e space2_cx[j][i]=%e\n"*/
		/*"spaceA_px[j][i]=%e space2_px[j][i]=%e\n",*/
		/*spaceA_cx[j][i], space2_cx[j][i],*/
		/*spaceA_px[j][i], space2_px[j][i]);*/
		assert(spaceA_cx[j][i] == space2_cx[j][i]
		       && spaceA_px[j][i] == space2_px[j][i]);
	    }
	}
    }

    /* kernel12 */

    if (kernel12_) {
	for (int i = 0; i < (N12 + 1); i++) {
	    //assert(one);
	    space1_x[i] = (i * 3 + 11);
	    spaceA_x[i] = (i * 3 + 11);
	    space1_y[i] = (i * 5 + 7);
	    spaceA_y[i] = (i * 5 + 7);
	}
	kernel12(N12, space1_x, space1_y);
	serial12(N12, spaceA_x, spaceA_y);
	for (int i = 0; i < (N12 + 1); i++) {
#if 0
	    printf("spaceA_x[i]=%e space1_x[i]=%e\n"
		   "spaceA_y[i]=%e space1_y[i]=%e\n",
		   spaceA_x[i], space1_x[i],
		   spaceA_y[i], space1_y[i]);
#endif
	    assert(spaceA_x[i] == space1_x[i]
		   && spaceA_y[i] == space1_y[i]);
	}
    }

    /* kernel14 */

    if (kernel14_) {
	for (int i = 0; i < (N14 + 1); i++) {
	    //assert(one);
	    space1_ex[i] = (i * 3 + 11);
	    space1_dex[i] = (i * 5 + 7);
	    space1_grd[i] = ((i * 13) % N14);
	}
	for (int i = 0; i < 2048; i++) {
	    //assert(one);
	    space1_rh[i] = (i + 23);
	    spaceA_rh[i] = (i + 23);
	}
	double flx = 79;
	kernel14(N14, flx, space1_rh, space1_grd, space1_ex, space1_dex);
	serial14(N14, flx, spaceA_rh, space1_grd, space1_ex, space1_dex);
	for (int i = 0; i < 2048; i++) {
#if 0
	    printf("spaceA_rh[i]=%e space1_rh[i]=%e\n",
		   spaceA_rh[i], space1_rh[i]);
#endif
	    assert(spaceA_rh[i] == space1_rh[i]);
	}
    }

    /* kernel18 */

    if (kernel18_) {
	for (int j = 0; j < 7; j++) {
	    for (int i = 0; i < (N18 + 1); i++) {
		space2_za[j][i] = (3 * i + 23);
		space2_zb[j][i] = (3 * i + 29);
		space2_zm[j][i] = (3 * i + 31);
		space2_zp[j][i] = (3 * i + 37);
		space2_zq[j][i] = (3 * i + 41);
		space2_zr[j][i] = (3 * i + 43);
		space2_zu[j][i] = (3 * i + 47);
		space2_zv[j][i] = (3 * i + 53);
		space2_zz[j][i] = (3 * i + 59);

		spaceA_za[j][i] = (3 * i + 23);
		spaceA_zb[j][i] = (3 * i + 29);
		spaceA_zm[j][i] = (3 * i + 31);
		spaceA_zp[j][i] = (3 * i + 37);
		spaceA_zq[j][i] = (3 * i + 41);
		spaceA_zr[j][i] = (3 * i + 43);
		spaceA_zu[j][i] = (3 * i + 47);
		spaceA_zv[j][i] = (3 * i + 53);
		spaceA_zz[j][i] = (3 * i + 59);
	    }
	}
	kernel18(N18, space2_zr, space2_zz, space2_za, space2_zb,
		 space2_zp, space2_zq, space2_zu, space2_zv, space2_zm);
	serial18(N18, spaceA_zr, spaceA_zz, spaceA_za, spaceA_zb,
		 spaceA_zp, spaceA_zq, spaceA_zu, spaceA_zv, spaceA_zm);
	for (int j = 0; j < 7; j++) {
	    for (int i = 0; i < (N18 + 1); i++) {
#if 0
		printf("spaceA_za[j][i]=%e, space2_za[j][i]=%e\n"
		       "spaceA_zb[j][i]=%e, space2_zb[j][i]=%e\n"
		       "spaceA_zm[j][i]=%e, space2_zm[j][i]=%e\n"
		       "spaceA_zp[j][i]=%e, space2_zp[j][i]=%e\n"
		       "spaceA_zq[j][i]=%e, space2_zq[j][i]=%e\n"
		       "spaceA_zr[j][i]=%e, space2_zr[j][i]=%e\n"
		       "spaceA_zu[j][i]=%e, space2_zu[j][i]=%e\n"
		       "spaceA_zv[j][i]=%e, space2_zv[j][i]=%e\n"
		       "spaceA_zz[j][i]=%e, space2_zz[j][i]=%e\n",
		       spaceA_za[j][i], space2_za[j][i],
		       spaceA_zb[j][i], space2_zb[j][i],
		       spaceA_zm[j][i], space2_zm[j][i],
		       spaceA_zp[j][i], space2_zp[j][i],
		       spaceA_zq[j][i], space2_zq[j][i],
		       spaceA_zr[j][i], space2_zr[j][i],
		       spaceA_zu[j][i], space2_zu[j][i],
		       spaceA_zv[j][i], space2_zv[j][i],
		       spaceA_zz[j][i], space2_zz[j][i]);
#endif
		double error = 1e-9;
		assert((spaceA_za[j][i] - space2_za[j][i]) <= error
		       && (spaceA_zb[j][i] - space2_zb[j][i]) <= error
		       && (spaceA_zm[j][i] - space2_zm[j][i]) <= error
		       && (spaceA_zp[j][i] - space2_zp[j][i]) <= error
		       && (spaceA_zq[j][i] - space2_zq[j][i]) <= error
		       && (spaceA_zr[j][i] - space2_zr[j][i]) <= error
		       && (spaceA_zu[j][i] - space2_zu[j][i]) <= error
		       && (spaceA_zv[j][i] - space2_zv[j][i]) <= error
		       && (spaceA_zz[j][i] - space2_zz[j][i]) <= error);
	    }
	}
    }

    /* kernel21 */

    if (kernel21_) {
	for (int j = 0; j < (N21 + 1); j++) {
	    for (int i = 0; i < 25; i++) {
		space2_px[j][i] = (((j + 3) * 25) + i + 11);
		spaceA_px[j][i] = (((j + 3) * 25) + i + 11);
		space2_cx[j][i] = (((j + 5) * 25) + i + 13);
	    }
	}
	for (int j = 0; j < 101; j++) {
	    for (int i = 0; i < 25; i++) {
		space2_vy[i][j] = (((j + 7) * 25) + i + 17);
	    }
	}
	kernel21(N21, space2_px, space2_vy, space2_cx);
	serial21(N21, spaceA_px, space2_vy, space2_cx);
	for (int j = 0; j < (N21 + 1); j++) {
	    for (int i = 0; i < 25; i++) {
		/*printf("spaceA_px[j][i]=%e, space2_px[j][i]=%e\n",*/
		/*spaceA_px[j][i], space2_px[j][i]);*/
		assert(spaceA_px[j][i] == space2_px[j][i]);
	    }
	}
    }

    return 0;
}

/* Livermore Loops coded in C        Latest File Modification  20 Oct 92,
 * by Tim Peters, Kendall Square Res. Corp. tim@ksr.com, ksr!tim@uunet.uu.net
 * SUBROUTINE KERNEL( TK)  replaces the Fortran routine in LFK Test program.
 ************************************************************************
 *                                                                      *
 *            KERNEL     executes 24 samples of "C" computation         *
 *                                                                      *
 *                TK(1) - total cpu time to execute only the 24 kernels.*
 *                TK(2) - total Flops executed by the 24 Kernels        *
 *                                                                      *
 ************************************************************************
 *                                                                      *
 *     L. L. N. L.   " C "   K E R N E L S:   M F L O P S               *
 *                                                                      *
 *     These kernels measure   " C "   numerical computation            *
 *     rates for  a  spectrum  of  cpu-limited computational            *
 *     structures or benchmarks.   Mathematical  through-put            *
 *     is measured  in  units  of millions of floating-point            *
 *     operations executed per second, called Megaflops/sec.            *
 *                                                                      *
 *     Fonzi's Law: There is not now and there never will be a language *
 *                  in which it is the least bit difficult to write     *
 *                  bad programs.                                       *
 *                                                    F.H.MCMAHON  1972 *
 ************************************************************************
 *Originally from  Greg Astfalk, AT&T, P.O.Box 900, Princeton, NJ. 08540*
 *               by way of Frank McMahon (LLNL).                        *
 *                                                                      *
 *                               REFERENCE                              *
 *                                                                      *
 *              F.H.McMahon,   The Livermore Fortran Kernels:           *
 *              A Computer Test Of The Numerical Performance Range,     *
 *              Lawrence Livermore National Laboratory,                 *
 *              Livermore, California, UCRL-53745, December 1986.       *
 *                                                                      *
 *       from:  National Technical Information Service                  *
 *              U.S. Department of Commerce                             *
 *              5285 Port Royal Road                                    *
 *              Springfield, VA.  22161                                 *
 *                                                                      *
 *    Changes made to correct many array subscripting problems,         *
 *      make more readable (added #define's), include the original      *
 *      FORTRAN versions of the runs as comments, and make more         *
 *      portable by Kelly O'Hair (LLNL) and Chuck Rasbold (LLNL).       *
 *                                                                      *
 ************************************************************************
 */
